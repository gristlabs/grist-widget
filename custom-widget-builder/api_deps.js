// THIS FILE WAS AUTOGENERATED BY ./generate.js
const definition = `
// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../grist-widget/js-fiddle/grain-rpc
//   ../../../../grist-widget/js-fiddle/ts-interface-checker

declare module 'grist' {
    import { ColumnsToMap, CustomSectionAPI, InteractionOptions, InteractionOptionsRequest, WidgetColumnMap } from 'grist/CustomSectionAPI';
    import { AccessTokenOptions, AccessTokenResult, FetchSelectedOptions, GristAPI, GristDocAPI, GristView } from 'grist/GristAPI';
    import { RowRecord } from 'grist/GristData';
    import { RenderOptions } from 'grist/RenderOptions';
    import { TableOperations } from 'grist/TableOperations';
    import { WidgetAPI } from 'grist/WidgetAPI';
    export * from 'grist/TypeCheckers';
    export * from 'grist/FileParserAPI';
    export * from 'grist/GristAPI';
    export * from 'grist/GristData';
    export * from 'grist/GristTable';
    export * from 'grist/ImportSourceAPI';
    export * from 'grist/StorageAPI';
    export * from 'grist/RenderOptions';
    export * from 'grist/WidgetAPI';
    export * from 'grist/CustomSectionAPI';
    import { Rpc } from 'grain-rpc';
    export const rpc: Rpc;
    export const api: GristAPI;
    export const coreDocApi: GristDocAPI;
    /**
        * Interface for the records backing a custom widget.
        */
    export const viewApi: GristView;
    /**
        * Interface for the state of a custom widget.
        */
    export const widgetApi: WidgetAPI;
    /**
        * Interface for the mapping of a custom widget.
        */
    export const sectionApi: CustomSectionAPI;
    export const commandApi: any;
    /**
        * Shortcut for {@link GristView.allowSelectBy}.
        */
    export const allowSelectBy: () => Promise<void>;
    /**
        * Shortcut for {@link GristView.setSelectedRows}.
        */
    export const setSelectedRows: (rowIds: number[] | null) => Promise<void>;
    /**
        * Sets the cursor position in a linked section.
        */
    export const setCursorPos: (pos: import("./GristAPI").CursorPos) => Promise<void>;
    /**
        * Same as {@link GristView.fetchSelectedTable | GristView.fetchSelectedTable},
        * but the option 'keepEncoded' is 'false' by default.
        */
    export function fetchSelectedTable(options?: FetchSelectedOptions): Promise<any>;
    /**
        * Same as {@link GristView.fetchSelectedRecord | GristView.fetchSelectedRecord},
        * but the option 'keepEncoded' is 'false' by default.
        */
    export function fetchSelectedRecord(rowId: number, options?: FetchSelectedOptions): Promise<any>;
    /**
        * A collection of methods for fetching document data. The
        * fetchSelectedTable and fetchSelectedRecord methods are
        * overridden to decode data by default.
        */
    export const docApi: GristDocAPI & GristView;
    export const on: (eventName: string | symbol, listener: (...args: any[]) => void) => Rpc;
    /**
        * Shortcut for {@link WidgetAPI.getOption}
        */
    export const getOption: (key: string) => Promise<any>;
    /**
        * Shortcut for {@link WidgetAPI.setOption}
        */
    export const setOption: (key: string, value: any) => Promise<void>;
    /**
        * Shortcut for {@link WidgetAPI.setOptions}
        */
    export const setOptions: (options: {
            [key: string]: any;
    }) => Promise<void>;
    /**
        * Shortcut for {@link WidgetAPI.getOptions}
        */
    export const getOptions: () => Promise<object | null>;
    /**
        * Shortcut for {@link WidgetAPI.clearOptions}
        */
    export const clearOptions: () => Promise<void>;
    /**
        * Get access to a table in the document. If no tableId specified, this
        * will use the current selected table (for custom widgets).
        * If a table does not exist, there will be no error until an operation
        * on the table is attempted.
        */
    export function getTable(tableId?: string): TableOperations;
    /**
        * Get an access token, for making API calls outside of the custom widget
        * API. There is no caching of tokens. The returned token can
        * be used to authorize regular REST API calls that access the content of the
        * document. For example, in a custom widget for a table with a 'Photos' column
        * containing attachments, the following code will update the 'src' of an
        * image with id 'the_image' to show the attachment:
        * '''js
        * grist.onRecord(async (record) => {
        *   const tokenInfo = await grist.docApi.getAccessToken({readOnly: true});
        *   const img = document.getElementById('the_image');
        *   const id = record.Photos[0];  // get an id of an attachment - there could be several
        *                                 // in a cell, for this example we just take the first.
        *   const src = '\${tokenInfo.baseUrl}/attachments/\${id}/download?auth=\${tokenInfo.token}';
        *   img.setAttribute('src', src);
        * });
        * '''
        */
    export function getAccessToken(options?: AccessTokenOptions): Promise<AccessTokenResult>;
    /**
        * Get the current selected table (for custom widgets).
        */
    export const selectedTable: TableOperations;
    export function getSelectedTableId(): Promise<string>;
    export function getSelectedTableIdSync(): string | undefined;
    /**
        * Used by tests to wait for all pending requests to settle.
        *
        * TODO: currently only waits for requests for mappings.
        *
        * @internal
        */
    export function testWaitForPendingRequests(): Promise<void | null>;
    /**
        * Renames columns in the result using columns mapping configuration passed in ready method.
        * Returns null if not all required columns were mapped or not widget doesn't support
        * custom column mapping.
        */
    export function mapColumnNames(data: any, options?: {
            columns?: ColumnsToMap;
            mappings?: WidgetColumnMap | null;
            reverse?: boolean;
    }): any;
    /**
        * Offer a convenient way to map data with renamed columns back into the
        * form used in the original table. This is useful for making edits to the
        * original table in a widget with column mappings. As for mapColumnNames(),
        * we don't attempt to do these transformations automatically.
        */
    export function mapColumnNamesBack(data: any, options?: {
            columns?: ColumnsToMap;
            mappings?: WidgetColumnMap | null;
    }): any;
    /**
        * For custom widgets, add a handler that will be called whenever the
        * row with the cursor changes - either by switching to a different row, or
        * by some value within the row potentially changing.  Handler may
        * in the future be called with null if the cursor moves away from
        * any row.
        * By default, 'options.keepEncoded' is 'false'.
        */
    export function onRecord(callback: (data: RowRecord | null, mappings: WidgetColumnMap | null) => unknown, options?: FetchSelectedOptions): void;
    /**
        * For custom widgets, add a handler that will be called whenever the
        * new (blank) row is selected.
        */
    export function onNewRecord(callback: (mappings: WidgetColumnMap | null) => unknown): void;
    /**
        * For custom widgets, add a handler that will be called whenever the
        * selected records change.
        * By default, 'options.format' is ''rows'' and 'options.keepEncoded' is 'false'.
        */
    export function onRecords(callback: (data: RowRecord[], mappings: WidgetColumnMap | null) => unknown, options?: FetchSelectedOptions): void;
    /**
        * For custom widgets, add a handler that will be called whenever the
        * widget options change (and on initial ready message). Handler will be
        * called with an object containing saved json options, or null if no options were saved.
        * The second parameter has information about the widgets relationship with
        * the document that contains it.
        */
    export function onOptions(callback: (options: any, settings: InteractionOptions) => unknown): void;
    /**
        * Calling 'addImporter(...)' adds a safeBrowser importer. It is a short-hand for forwarding calls
        * to an 'ImportSourceAPI' implementation registered in the file at 'path'. It takes care of
        * creating the stub, registering an implementation that renders the file, forward the call and
        * dispose the view properly. If 'mode' is ''inline'' embeds the view in the import modal, otherwise
        * renders fullscreen.
        *
        * Notes: it assumes that file at 'path' registers an 'ImportSourceAPI' implementation under
        * 'name'. Calling 'addImporter(...)' from another component than a 'safeBrowser' component is not
        * currently supported.
        *
        * @internal
        */
    export function addImporter(name: string, path: string, mode: 'fullscreen' | 'inline', options?: RenderOptions): Promise<void>;
    export function enableKeyboardShortcuts(): void;
    /**
        * Options when initializing connection to Grist.
        */
    export interface ReadyPayload extends Omit<InteractionOptionsRequest, "hasCustomOptions"> {
            /**
                * Handler that will be called by Grist to open additional configuration panel inside the Custom Widget.
                */
            onEditOptions?: () => unknown;
    }
    /**
        * Declare that a component is prepared to receive messages from the outside world.
        * Grist will not attempt to communicate with it until this method is called.
        */
    export function ready(settings?: ReadyPayload): void;
}

declare module 'grist/CustomSectionAPI' {
    /**
        * API definitions for CustomSection plugins.
        */
    export interface ColumnToMap {
            /**
                * Column name that Widget expects. Must be a valid JSON property name.
                */
            name: string;
            /**
                * Title or short description of a column (used as a label in section mapping).
                */
            title?: string | null;
            /**
                * Optional long description of a column (used as a help text in section mapping).
                */
            description?: string | null;
            /**
                * Column types (as comma separated list), by default "Any", what means that any type is
                * allowed (unless strictType is true).
                */
            type?: string;
            /**
                * Mark column as optional all columns are required by default.
                */
            optional?: boolean;
            /**
                * Allow multiple column assignment, the result will be list of mapped table column names.
                */
            allowMultiple?: boolean;
            /**
                * Match column type strictly, so "Any" will require "Any" and not any other type.
                */
            strictType?: boolean;
    }
    /**
        * Tells Grist what columns a Custom Widget expects and allows users to map between existing column names
        * and those requested by the Custom Widget.
        */
    export type ColumnsToMap = (string | ColumnToMap)[];
    /**
        * Initial message sent by the CustomWidget with initial requirements.
        */
    export interface InteractionOptionsRequest {
            /**
                * Required access level. If it wasn't granted already, Grist will prompt user to change the current access
                * level.
                */
            requiredAccess?: string;
            /**
                * Instructs Grist to show additional menu options that will trigger onEditOptions callback, that Widget
                * can use to show custom options screen.
                */
            hasCustomOptions?: boolean;
            /**
                * Tells Grist what columns Custom Widget expects and allows user to map between existing column names
                * and those requested by Custom Widget.
                */
            columns?: ColumnsToMap;
            /**
                * Show widget as linking source.
                */
            allowSelectBy?: boolean;
    }
    /**
        * Widget configuration set and approved by Grist, sent as part of ready message.
        */
    export interface InteractionOptions {
            /**
                * Granted access level.
                */
            accessLevel: string;
    }
    /**
        * Current columns mapping between viewFields in section and Custom widget.
        */
    export interface WidgetColumnMap {
            [key: string]: string | string[] | null;
    }
    /**
        * Interface for the mapping of a custom widget.
        */
    export interface CustomSectionAPI {
            /**
                * Initial request from a Custom Widget that wants to declare its requirements.
                */
            configure(customOptions: InteractionOptionsRequest): Promise<void>;
            /**
                * Returns current widget configuration (if requested through configuration method).
                */
            mappings(): Promise<WidgetColumnMap | null>;
    }
}

declare module 'grist/GristAPI' {
    /**
        * This file defines the interface for the grist api exposed to SafeBrowser plugins. Grist supports
        * various ways to require it to cover various scenarios. If writing the main safeBrowser module
        * (the one referenced by the components.safeBrowser key of the manifest) use
        * 'self.importScript('grist');', if writing a view include the script in the html '<script src="grist"></script>'
        *
        *
        * Example usage (let's assume that Grist let's plugin contributes to a Foo API defined as follow ):
        *
        * interface Foo {
        *   foo(name: string): Promise<string>;
        * }
        *
        * > main.ts:
        * class MyFoo {
        *   public foo(name: string): Promise<string> {
        *     return new Promise<string>( async resolve => {
        *       grist.rpc.onMessage( e => {
        *         resolve(e.data + name);
        *       });
        *       grist.ready();
        *       await grist.api.render('view1.html', 'fullscreen');
        *     });
        *   }
        * }
        * grist.rpc.registerImpl<Foo>('grist', new MyFoo()); // can add 3rd arg with type information
        *
        * > view1.html includes:
        * grist.api.render('static/view2.html', 'fullscreen').then( view => {
        *   grist.rpc.onMessage(e => grist.rpc.postMessageForward("main.ts", e.data));
        * });
        *
        * > view2.html includes:
        * grist.rpc.postMessage('view1.html', 'foo ');
        *
        */
    import { RenderOptions, RenderTarget } from 'grist/RenderOptions';
    /**
        * Represents the id of a row in a table. The value of the 'id' column. Might be a number or 'new' value for a new row.
        */
    export type UIRowId = number | 'new';
    /**
        * Represents the position of an active cursor on a page.
        */
    export interface CursorPos {
            /**
                * The rowId (value of the 'id' column) of the current cursor position, or 'new' if the cursor is on a new row.
                */
            rowId?: UIRowId;
            /**
                * The index of the current row in the current view.
                */
            rowIndex?: number;
            /**
                * The index of the selected field in the current view.
                */
            fieldIndex?: number;
            /**
                * The id of a section that this cursor is in. Ignored when setting a cursor position for a particular view.
                */
            sectionId?: number;
            /**
                * When in a linked section, CursorPos may include which rows in the controlling sections are
                * selected: the rowId in the linking-source section, in _that_ section's linking source, etc.
                */
            linkingRowIds?: UIRowId[];
    }
    export type ComponentKind = "safeBrowser" | "safePython" | "unsafeNode";
    export const RPC_GRISTAPI_INTERFACE = "_grist_api";
    export interface GristAPI {
            /**
                * Render the file at 'path' into the 'target' location in Grist. 'path' must be relative to the
                * root of the plugin's directory and point to an html that is contained within the plugin's
                * directory. 'target' is a predefined location of the Grist UI, it could be 'fullscreen' or
                * identifier for an inline target. Grist provides inline target identifiers in certain call
                * plugins. E.g. ImportSourceAPI.getImportSource is given a target identifier to allow rende UI
                * inline in the import dialog. Returns the procId which can be used to dispose the view.
                */
            render(path: string, target: RenderTarget, options?: RenderOptions): Promise<number>;
            /**
                * Dispose the process with id procId. If the process was embedded into the UI, removes the
                * corresponding element from the view.
                */
            dispose(procId: number): Promise<void>;
            subscribe(tableId: string): Promise<void>;
            unsubscribe(tableId: string): Promise<void>;
    }
    /**
        * Allows getting information from and interacting with the Grist document to which a plugin or widget is attached.
        */
    export interface GristDocAPI {
            /**
                * Returns an identifier for the document.
                */
            getDocName(): Promise<string>;
            /**
                * Returns a sorted list of table IDs.
                */
            listTables(): Promise<string[]>;
            /**
                * Returns a complete table of data as {@link GristData.RowRecords | GristData.RowRecords}, including the
                * 'id' column. Do not modify the returned arrays in-place, especially if used
                * directly (not over RPC).
                */
            fetchTable(tableId: string): Promise<any>;
            /**
                * Applies an array of user actions.
                */
            applyUserActions(actions: any[][], options?: any): Promise<any>;
            /**
                * Get a token for out-of-band access to the document.
                */
            getAccessToken(options: AccessTokenOptions): Promise<AccessTokenResult>;
    }
    /**
        * Options for functions which fetch data from the selected table or record:
        *
        * - {@link onRecords}
        * - {@link onRecord}
        * - {@link fetchSelectedRecord}
        * - {@link fetchSelectedTable}
        * - {@link GristView.fetchSelectedRecord | GristView.fetchSelectedRecord}
        * - {@link GristView.fetchSelectedTable | GristView.fetchSelectedTable}
        *
        * The different methods have different default values for 'keepEncoded' and 'format'.
        **/
    export interface FetchSelectedOptions {
            /**
                * - 'true': the returned data will contain raw {@link GristData.CellValue}'s.
                * - 'false': the values will be decoded, replacing e.g. '['D', timestamp]' with a moment date.
                */
            keepEncoded?: boolean;
            /**
                * - 'rows', the returned data will be an array of objects, one per row, with column names as keys.
                * - 'columns', the returned data will be an object with column names as keys, and arrays of values.
                */
            format?: 'rows' | 'columns';
            /**
                * - 'shown' (default): return only columns that are explicitly shown
                *   in the right panel configuration of the widget. This is the only value that doesn't require full access.
                * - 'normal': return all 'normal' columns, regardless of whether the user has shown them.
                * - 'all': also return special invisible columns like 'manualSort' and display helper columns.
                */
            includeColumns?: 'shown' | 'normal' | 'all';
    }
    /**
        * Interface for the data backing a single widget.
        */
    export interface GristView {
            /**
                * Like {@link GristDocAPI.fetchTable | GristDocAPI.fetchTable},
                * but gets data for the custom section specifically, if there is any.
                * By default, 'options.keepEncoded' is 'true' and 'format' is 'columns'.
                */
            fetchSelectedTable(options?: FetchSelectedOptions): Promise<any>;
            /**
                * Fetches selected record by its 'rowId'. By default, 'options.keepEncoded' is 'true'.
                */
            fetchSelectedRecord(rowId: number, options?: FetchSelectedOptions): Promise<any>;
            /**
                * Deprecated now. It was used for filtering selected table by 'setSelectedRows' method.
                * Now the preferred way it to use ready message.
                */
            allowSelectBy(): Promise<void>;
            /**
                * Set the list of selected rows to be used against any linked widget.
                */
            setSelectedRows(rowIds: number[] | null): Promise<void>;
            /**
                * Sets the cursor position to a specific row and field. 'sectionId' is ignored. Used for widget linking.
                */
            setCursorPos(pos: CursorPos): Promise<void>;
    }
    /**
        * Options when creating access tokens.
        */
    export interface AccessTokenOptions {
            /** Restrict use of token to reading only */
            readOnly?: boolean;
    }
    /**
        * Access token information, including the token string itself, a base URL for
        * API calls for which the access token can be used, and the time-to-live the
        * token was created with.
        */
    export interface AccessTokenResult {
            /**
                * The token string, which can currently be provided in an api call as a
                * query parameter called "auth"
                */
            token: string;
            /**
                * The base url of the API for which the token can be used. Currently tokens
                * are associated with a single document, so the base url will be something
                * like 'https://..../api/docs/DOCID'
                *
                * Access tokens currently only grant access to endpoints dealing with the
                * internal content of a document (such as tables and cells) and not its
                * metadata (such as the document name or who it is shared with).
                */
            baseUrl: string;
            /**
                * Number of milliseconds the access token will remain valid for
                * after creation. This will be several minutes.
                */
            ttlMsecs: number;
    }
}

declare module 'grist/GristData' {
    /**
        * Letter codes for {@link CellValue} types encoded as [code, args...] tuples.
        */
    export enum GristObjCode {
            List = "L",
            LookUp = "l",
            Dict = "O",
            DateTime = "D",
            Date = "d",
            Skip = "S",
            Censored = "C",
            Reference = "R",
            ReferenceList = "r",
            Exception = "E",
            Pending = "P",
            Unmarshallable = "U",
            Versions = "V"
    }
    /**
        * Possible types of cell content.
        *
        * Each 'CellValue' may either be a primitive (e.g. 'true', '123', '"hello"', 'null')
        * or a tuple (JavaScript Array) representing a Grist object. The first element of the tuple
        * is a string character representing the object code. For example, '["L", "foo", "bar"]'
        * is a 'CellValue' of a Choice List column, where '"L"' is the type, and '"foo"' and
        * '"bar"' are the choices.
        *
        * ### Grist Object Types
        *
        * | Code | Type           |
        * | ---- | -------------- |
        * | 'L'  | List, e.g. '["L", "foo", "bar"]' or '["L", 1, 2]' |
        * | 'l'  | LookUp, as '["l", value, options]' |
        * | 'O'  | Dict, as '["O", {key: value, ...}]' |
        * | 'D'  | DateTimes, as '["D", timestamp, timezone]', e.g. '["D", 1704945919, "UTC"]' |
        * | 'd'  | Date, as '["d", timestamp]', e.g. '["d", 1704844800]' |
        * | 'C'  | Censored, as '["C"]' |
        * | 'R'  | Reference, as '["R", table_id, row_id]', e.g. '["R", "People", 17]' |
        * | 'r'  | ReferenceList, as '["r", table_id, row_id_list]', e.g. '["r", "People", [1,2]]' |
        * | 'E'  | Exception, as '["E", name, ...]', e.g. '["E", "ValueError"]' |
        * | 'P'  | Pending, as '["P"]' |
        * | 'U'  | Unmarshallable, as '["U", text_representation]' |
        * | 'V'  | Version, as '["V", version_obj]' |
        */
    export type CellValue = number | string | boolean | null | [GristObjCode, ...unknown[]];
    export interface BulkColValues {
            [colId: string]: CellValue[];
    }
    /**
        * Map of column ids to {@link CellValue}'s.
        */
    export interface RowRecord {
            id: number;
            [colId: string]: CellValue;
    }
    /**
        * Map of column ids to {@link CellValue} arrays, where array indexes correspond to
        * rows.
        */
    export interface RowRecords {
            id: number[];
            [colId: string]: CellValue[];
    }
    export type GristType = 'Any' | 'Attachments' | 'Blob' | 'Bool' | 'Choice' | 'ChoiceList' | 'Date' | 'DateTime' | 'Id' | 'Int' | 'ManualSortPos' | 'Numeric' | 'PositionNumber' | 'Ref' | 'RefList' | 'Text';
}

declare module 'grist/RenderOptions' {
    /**
        * Where to append the content that a plugin renders.
        *
        * @internal
        */
    export type RenderTarget = "fullscreen" | number;
    /**
        * Options for the 'grist.render' function.
        */
    export interface RenderOptions {
            height?: string;
    }
}

declare module 'grist/TableOperations' {
    import * as Types from 'grist/DocApiTypes';
    /**
        * Offer CRUD-style operations on a table.
        */
    export interface TableOperations {
            /**
                * Create a record or records.
                */
            create(records: Types.NewRecord, options?: OpOptions): Promise<Types.MinimalRecord>;
            create(records: Types.NewRecord[], options?: OpOptions): Promise<Types.MinimalRecord[]>;
            /**
                * Update a record or records.
                */
            update(records: Types.Record | Types.Record[], options?: OpOptions): Promise<void>;
            /**
                * Delete a record or records.
                */
            destroy(recordIds: Types.RecordId | Types.RecordId[]): Promise<void>;
            /**
                * Add or update a record or records.
                */
            upsert(records: Types.AddOrUpdateRecord | Types.AddOrUpdateRecord[], options?: UpsertOptions): Promise<void>;
            /**
                * Determine the tableId of the table.
                */
            getTableId(): Promise<string>;
    }
    /**
        * General options for table operations.
        */
    export interface OpOptions {
            /** Whether to parse strings based on the column type. Defaults to true. */
            parseStrings?: boolean;
    }
    /**
        * Extra options for upserts.
        */
    export interface UpsertOptions extends OpOptions {
            /** Permit inserting a record. Defaults to true. */
            add?: boolean;
            /** Permit updating a record. Defaults to true. */
            update?: boolean;
            /** Whether to update none, one, or all matching records. Defaults to "first". */
            onMany?: 'none' | 'first' | 'all';
            /** Allow "wildcard" operation. Defaults to false. */
            allowEmptyRequire?: boolean;
    }
}

declare module 'grist/WidgetAPI' {
    /**
        * API to manage Custom Widget state.
        */
    export interface WidgetAPI {
            /**
                * Gets all options stored by the widget. Options are stored as plain JSON object.
                */
            getOptions(): Promise<object | null>;
            /**
                * Replaces all options stored by the widget.
                */
            setOptions(options: {
                    [key: string]: any;
            }): Promise<void>;
            /**
                * Clears all the options.
                */
            clearOptions(): Promise<void>;
            /**
                * Store single value in the Widget options object (and create it if necessary).
                */
            setOption(key: string, value: any): Promise<void>;
            /**
                * Get single value from Widget options object.
                */
            getOption(key: string): Promise<any>;
    }
}

declare module 'grist/TypeCheckers' {
    import { ICheckerSuite } from 'ts-interface-checker';
    import CustomSectionAPITI from 'grist/CustomSectionAPI-ti';
    import FileParserAPITI from 'grist/FileParserAPI-ti';
    import GristAPITI from 'grist/GristAPI-ti';
    import GristTableTI from 'grist/GristTable-ti';
    import ImportSourceAPITI from 'grist/ImportSourceAPI-ti';
    import InternalImportSourceAPITI from 'grist/InternalImportSourceAPI-ti';
    import RenderOptionsTI from 'grist/RenderOptions-ti';
    import StorageAPITI from 'grist/StorageAPI-ti';
    import WidgetAPITI from 'grist/WidgetAPI-ti';
    /**
        * The ts-interface-checker type suites are all exported with the "TI" suffix.
        */
    export { CustomSectionAPITI, FileParserAPITI, GristAPITI, GristTableTI, ImportSourceAPITI, InternalImportSourceAPITI, RenderOptionsTI, StorageAPITI, WidgetAPITI };
    /**
        * We also create and export a global checker object that includes all of the types above.
        */
    export const checkers: Pick<ICheckerSuite, "CustomSectionAPI" | "ParseOptions" | "ParseFileResult" | "FileSource" | "ParseOptionSchema" | "GristTables" | "EditOptionsAPI" | "ParseFileAPI" | "RenderTarget" | "RenderOptions" | "ComponentKind" | "GristAPI" | "GristDocAPI" | "GristView" | "GristColumn" | "GristTable" | "ImportSourceAPI" | "ImportProcessorAPI" | "ImportSource" | "FileContent" | "FileListItem" | "URL" | "InternalImportSourceAPI" | "Storage" | "WidgetAPI">;
}

declare module 'grist/FileParserAPI' {
    /**
        * API definitions for FileParser plugins.
        */
    import { GristTables } from 'grist/GristTable';
    export interface EditOptionsAPI {
            getParseOptions(parseOptions?: ParseOptions): Promise<ParseOptions>;
    }
    export interface ParseFileAPI {
            parseFile(file: FileSource, parseOptions?: ParseOptions): Promise<ParseFileResult>;
    }
    /**
        * ParseOptions contains parse options depending on plugin,
        * number of rows, which is special option that can be used for any plugin
        * and schema for generating parse options UI
        */
    export interface ParseOptions {
            NUM_ROWS?: number;
            SCHEMA?: ParseOptionSchema[];
            WARNING?: string;
    }
    /**
        * ParseOptionSchema contains information for generaing parse options UI
        */
    export interface ParseOptionSchema {
            name: string;
            label: string;
            type: string;
            visible: boolean;
    }
    export interface FileSource {
            /**
                * The path is often a temporary file, so its name is meaningless. Access to the file depends on
                * the type of plugin. For instance, for 'safePython' plugins file is directly available at
                * '/importDir/path'.
                */
            path: string;
            /**
                * Plugins that want to know the original filename should use origName. Depending on the source
                * of the data, it may or may not be meaningful.
                */
            origName: string;
    }
    export interface ParseFileResult extends GristTables {
            parseOptions: ParseOptions;
    }
}

declare module 'grist/GristTable' {
    /**
        * Metadata and data for a table.
        */
    export interface GristTable {
            table_name: string | null;
            column_metadata: GristColumn[];
            table_data: any[][];
    }
    export interface GristTables {
            tables: GristTable[];
    }
    /**
        * Metadata about a single column.
        */
    export interface GristColumn {
            id: string;
            type: string;
    }
    export enum APIType {
            ImportSourceAPI = 0,
            ImportProcessorAPI = 1,
            ParseOptionsAPI = 2,
            ParseFileAPI = 3
    }
}

declare module 'grist/ImportSourceAPI' {
    /**
        * API definitions for ImportSource plugins.
        */
    import { GristTable } from 'grist/GristTable';
    export interface ImportSourceAPI {
            /**
                * Returns a promise that resolves to an 'ImportSource' which is then passed for import to the
                * import modal dialog. 'undefined' interrupts the workflow and prevent the modal from showing up,
                * but not an empty list of 'ImportSourceItem'. Which is a valid import source and is used in
                * cases where only options are to be sent to an 'ImportProcessAPI' implementation.
                */
            getImportSource(): Promise<ImportSource | undefined>;
    }
    export interface ImportProcessorAPI {
            processImport(source: ImportSource): Promise<GristTable[]>;
    }
    export interface FileContent {
            content: any;
            name: string;
    }
    export interface FileListItem {
            kind: "fileList";
            files: FileContent[];
    }
    export interface URL {
            kind: "url";
            url: string;
    }
    export interface ImportSource {
            item: FileListItem | URL;
            /**
                * The options are only passed within this plugin, nothing else needs to know how they are
                * serialized. Using JSON.stringify/JSON.parse is a simple approach.
                */
            options?: string | Buffer;
            /**
                * The short description that shows in the import dialog after source have been selected.
                */
            description?: string;
    }
}

declare module 'grist/StorageAPI' {
    export interface Storage {
        getItem(key: string): any;
        hasItem(key: string): boolean;
        setItem(key: string, value: any): void;
        removeItem(key: string): void;
        clear(): void;
    }
}

declare module 'grist/DocApiTypes' {
    import { CellValue } from "grist/GristData";
    /**
        * JSON schema for api /record endpoint. Used in POST method for adding new records.
        */
    export interface NewRecord {
            /**
                * Initial values of cells in record. Optional, if not set cells are left
                * blank.
                */
            fields?: {
                    [coldId: string]: CellValue;
            };
    }
    export interface NewRecordWithStringId {
            id?: string;
            /**
                * Initial values of cells in record. Optional, if not set cells are left
                * blank.
                */
            fields?: {
                    [coldId: string]: CellValue;
            };
    }
    /**
        * JSON schema for api /record endpoint. Used in PATCH method for updating existing records.
        */
    export interface Record {
            id: number;
            fields: {
                    [coldId: string]: CellValue;
            };
    }
    export interface RecordWithStringId {
            id: string;
            fields: {
                    [coldId: string]: CellValue;
            };
    }
    /**
        * JSON schema for api /record endpoint. Used in PUT method for adding or updating records.
        */
    export interface AddOrUpdateRecord {
            /**
                * The values we expect to have in particular columns, either by matching with
                * an existing record, or creating a new record.
                */
            require: {
                    [coldId: string]: CellValue;
            } & {
                    id?: number;
            };
            /**
                * The values we will place in particular columns, either overwriting values in
                * an existing record, or setting initial values in a new record.
                */
            fields?: {
                    [coldId: string]: CellValue;
            };
    }
    /**
        * JSON schema for the body of api /record PATCH endpoint
        */
    export interface RecordsPatch {
            records: [Record, ...Record[]];
    }
    /**
        * JSON schema for the body of api /record POST endpoint
        */
    export interface RecordsPost {
            records: [NewRecord, ...NewRecord[]];
    }
    /**
        * JSON schema for the body of api /record PUT endpoint
        */
    export interface RecordsPut {
            records: [AddOrUpdateRecord, ...AddOrUpdateRecord[]];
    }
    export type RecordId = number;
    /**
        * The row id of a record, without any of its content.
        */
    export interface MinimalRecord {
            id: number;
    }
    export interface ColumnsPost {
            columns: [NewRecordWithStringId, ...NewRecordWithStringId[]];
    }
    export interface ColumnsPatch {
            columns: [RecordWithStringId, ...RecordWithStringId[]];
    }
    export interface ColumnsPut {
            columns: [RecordWithStringId, ...RecordWithStringId[]];
    }
    /**
        * Creating tables requires a list of columns.
        * 'fields' is not accepted because it's not generally sensible to set the metadata fields on new tables.
        */
    export interface TablePost extends ColumnsPost {
            id?: string;
    }
    export interface TablesPost {
            tables: [TablePost, ...TablePost[]];
    }
    export interface TablesPatch {
            tables: [RecordWithStringId, ...RecordWithStringId[]];
    }
    /**
        * JSON schema for the body of api /sql POST endpoint
        */
    export interface SqlPost {
            sql: string;
            args?: any[];
            timeout?: number;
    }
}

declare module 'grist/CustomSectionAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const ColumnToMap: t.TIface;
    export const ColumnsToMap: t.TArray;
    export const InteractionOptionsRequest: t.TIface;
    export const InteractionOptions: t.TIface;
    export const WidgetColumnMap: t.TIface;
    export const CustomSectionAPI: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/FileParserAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const EditOptionsAPI: t.TIface;
    export const ParseFileAPI: t.TIface;
    export const ParseOptions: t.TIface;
    export const ParseOptionSchema: t.TIface;
    export const FileSource: t.TIface;
    export const ParseFileResult: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/GristAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const UIRowId: t.TUnion;
    export const CursorPos: t.TIface;
    export const ComponentKind: t.TUnion;
    export const GristAPI: t.TIface;
    export const GristDocAPI: t.TIface;
    export const FetchSelectedOptions: t.TIface;
    export const GristView: t.TIface;
    export const AccessTokenOptions: t.TIface;
    export const AccessTokenResult: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/GristTable-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const GristTable: t.TIface;
    export const GristTables: t.TIface;
    export const GristColumn: t.TIface;
    export const APIType: t.TEnumType;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/ImportSourceAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const ImportSourceAPI: t.TIface;
    export const ImportProcessorAPI: t.TIface;
    export const FileContent: t.TIface;
    export const FileListItem: t.TIface;
    export const URL: t.TIface;
    export const ImportSource: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/InternalImportSourceAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const InternalImportSourceAPI: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/RenderOptions-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const RenderTarget: t.TUnion;
    export const RenderOptions: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/StorageAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const Storage: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/WidgetAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const WidgetAPI: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}


// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../../grist-widget/js-fiddle/events
//   ../../../../../grist-widget/js-fiddle/ts-interface-checker

declare module 'grain-rpc' {
    export * from 'grain-rpc/message';
    export * from 'grain-rpc/rpc';
}

declare module 'grain-rpc/message' {
    /**
      * This defines the message types sent over an RpcChannel.
      *
      * WARNING: Any changes to these must be backward-compatible, since Rpc may be used across
      * different versions of this library. Specifically, enums must not be renumbered, fields renamed,
      * or their types changed. Really, the only reasonable enhancement is adding a new optional field.
      */
    export enum MsgType {
        RpcCall = 1,
        RpcRespData = 2,
        RpcRespErr = 3,
        Custom = 4,
        Ready = 5,
    }
    export interface IMsgRpcCall {
        mtype: MsgType.RpcCall;
        mdest?: string;
        reqId?: number;
        iface: string;
        meth: string;
        args: any[];
    }
    export interface IMsgRpcRespData {
        mtype: MsgType.RpcRespData;
        reqId: number;
        data?: any;
    }
    export interface IMsgRpcRespErr {
        mtype: MsgType.RpcRespErr;
        reqId: number;
        mesg: string;
        code?: string;
    }
    export interface IMsgCustom {
        mtype: MsgType.Custom;
        mdest?: string;
        data: any;
    }
    export interface IMsgReady {
        mtype: MsgType.Ready;
    }
    export type IMsgRpc = IMsgRpcCall | IMsgRpcRespData | IMsgRpcRespErr;
    export type IMessage = IMsgRpc | IMsgCustom | IMsgReady;
}

declare module 'grain-rpc/rpc' {
    /**
        * Rpc implements an remote-procedure-call interface on top of a simple messaging interface.
        *
        * The user must provide the messaging between two endpoints, and in return gets the ability to
        * register interfaces or functions at either endpoint, and call them from the other side. For
        * messaging, the user must supply a sendMessage() function to send messages to the other side,
        * and must call rpc.receiveMessage(msg) whenever a message is received.
        *
        * E.g.
        *    rpc.registerImpl<MyInterface>("some-name", new MyInterfaceImpl(), descMyInterfaceImpl);
        *    rpc.getStub<MyInterface>("some-name", descMyInterfaceImpl)
        *          => returns a stub implemeting MyInterface
        *
        * Calls to the generated stub get turned into messages across the channel, and then call to the
        * implementation object registered on the other side. Both return values and exceptions get
        * passed back over the channel, and cause the promise from the stub to be resolved or rejected.
        *
        * Note that the stub interface returns Promises for all methods.
        *
        * Rpc library supports ts-interface-checker descriptors for the interfaces, to allow validation.
        * You may skip it by passing in 'rpc.unchecked' where a descriptor is expected; it will skip
        * checks and you will not get descriptive errors.
        *
        * The string name used to register and use an implementation allows for the same Rpc object to be
        * used to expose multiple interfaces, or different implementations of the same interface.
        *
        * Messaging
        * ---------
        * Rpc also supports a messaging interface, with postMessage() to send arbitrary messages, and an
        * EventEmitter interface for "message" events to receive them, e.g. on("message", ...). So if you
        * need to multiplex non-Rpc messages over the same channel, Rpc class does it for you.
        *
        * Cleanup
        * -------
        * If the channel is closed or had an error, and will no longer be used, the user of Rpc must
        * call rpc.close() to reject any calls waiting for an answer.
        *
        * If a particular stub for a remote API is no longer needed, user may call rpc.discardStub(stub)
        * to reject any pending calls made to that stub.
        *
        * Timeouts
        * --------
        * TODO (Not yet implementd.)
        * You may call rpc.setTimeout(ms) or rpc.setStubTimeout(stub, ms) to set a call timeout for all
        * stubs or for a particular one. If a response to a call does not arrive within the timeout, the
        * call gets rejected, and the rejection Error will have a "code" property set to "TIMEOUT".
        *
        * Forwarding
        * ----------
        * Rpc.registerForwarder() along with methods with "-Forward" suffix allow one Rpc object to forward
        * calls and messages to another Rpc object. The intended usage is when Rpc connects A to B, and B
        * to C. Then B can use registerForwarder to expose A's interfaces to C (or C's to A) without having
        * to know what exactly they are. A default forwarder can be registered using the '*' name.
        *
        *
        * Instead of using getStubForward and callRemoteFuncForward, the forwarder name can be
        * appended to the interface name as "interfaceName@forwarderName" and the regular
        * getStub and callRemoteFunc methods can be used.  For example:
        *   getStub("iface@forwarder")
        * is the same as:
        *   getStubForward("forwarder", "iface")
        *
        *
        * E.g. with A.registerImpl("A-name", ...) and B.registerForwarder("b2a", A), we may now call
        * C.getStubForward("b2a", "A-name") to get a stub that will forward calls to A, as well as
        * C.postMessageForward("b2a", msg) to have the message received by A.
        *
        * TODO We may want to support progress callbacks, perhaps by supporting arbitrary callbacks as
        * parameters. (Could be implemented by allowing "meth" to be [reqId, paramPath]) It would be nice
        * to allow the channel to report progress too, e.g. to report progress of uploading large files.
        *
        * TODO Sending of large files should probably be a separate feature, to allow for channel
        * implementations to stream them.
        */
    import { EventEmitter } from "events";
    import * as tic from "ts-interface-checker";
    import { IMessage, IMsgCustom, IMsgRpcCall } from "grain-rpc/message";
    export type SendMessageCB = (msg: IMessage) => Promise<void> | void;
    export interface IForwarderDest {
            forwardCall: (c: IMsgRpcCall) => Promise<any>;
            forwardMessage: (msg: IMsgCustom) => Promise<any>;
    }
    export type ICallWrapper = (callFunc: () => Promise<any>) => Promise<any>;
    export class Rpc extends EventEmitter implements IForwarderDest {
            /**
                * To use Rpc, you must provide a sendMessage function that sends a message to the other side;
                * it may be given in the constructor, or later with setSendMessage. You must also call
                * receiveMessage() for every message received from the other side.
                */
            constructor(options?: {
                    logger?: IRpcLogger;
                    sendMessage?: SendMessageCB;
                    callWrapper?: ICallWrapper;
            });
            /**
                * To use Rpc, call this for every message received from the other side of the channel.
                */
            receiveMessage(msg: IMessage): void;
            /**
                * If you've set up calls to receiveMessage(), but need time to call registerImpl() before
                * processing new messages, you may use queueIncoming(), make the registerImpl() calls,
                * and then call processIncoming() to handle queued messages and resume normal processing.
                */
            queueIncoming(): void;
            /**
                * Process received messages queued since queueIncoming, and resume normal processing of
                * received messages.
                */
            processIncoming(): void;
            /**
                * Set the callback to send messages. If set to null, sent messages will be queued. If you
                * disconnect and want for sent messages to throw, set a callback that throws.
                */
            setSendMessage(sendMessage: SendMessageCB | null): void;
            /**
                * If your peer may not be listening yet to your messages, you may call this to queue outgoing
                * messages until receiving a "ready" message from the peer. I.e. one peer may call
                * queueOutgoingUntilReadyMessage() while the other calls sendReadyMessage().
                */
            queueOutgoingUntilReadyMessage(): void;
            /**
                * If your peer is using queueOutgoingUntilReadyMessage(), you should let it know that you are
                * ready using sendReadyMessage() as soon as you've set up the processing of received messages.
                * Note that at most one peer may use queueOutgoingUntilReadyMessage(), or they will deadlock.
                */
            sendReadyMessage(): void | Promise<void>;
            /**
                * Messaging interface: send data to the other side, to be emitted there as a "message" event.
                */
            postMessage(data: any): Promise<void>;
            postMessageForward(fwdDest: string, data: any): Promise<void>;
            /**
                * Registers a new implementation under the given name. It is an error if this name is already
                * in use. To skip all validation, use 'registerImpl<any>(...)' and omit the last argument.
                * TODO Check that registerImpl without a type param requires a checker.
                */
            registerImpl<Iface extends any>(name: string, impl: any): void;
            registerImpl<Iface>(name: string, impl: Iface, checker: tic.Checker): void;
            registerForwarder(fwdName: string, dest: IForwarderDest, fwdDest?: string): void;
            unregisterForwarder(fwdName: string): void;
            /**
                * Unregister an implementation, if one was registered with this name.
                */
            unregisterImpl(name: string): void;
            /**
                * Creates a local stub for the given remote interface. The stub implements Iface, forwarding
                * calls to the remote implementation, each one returning a Promise for the received result.
                * To skip all validation, use 'any' for the type and omit the last argument.
                *
                * Interface names can be followed by a "@<forwarder>" part
                */
            getStub<Iface extends any>(name: string): Iface;
            getStub<Iface>(name: string, checker: tic.Checker): Iface;
            getStubForward<Iface extends any>(fwdDest: string, name: string): any;
            getStubForward<Iface>(fwdDest: string, name: string, checker: tic.Checker): Iface;
            /**
                * Simple way to registers a function under a given name, with no argument checking.
                */
            registerFunc(name: string, impl: (...args: any[]) => any): void;
            /**
                * Unregister a function, if one was registered with this name.
                */
            unregisterFunc(name: string): void;
            /**
                * Call a remote function registered with registerFunc. Does no type checking.
                */
            callRemoteFunc(name: string, ...args: any[]): Promise<any>;
            callRemoteFuncForward(fwdDest: string, name: string, ...args: any[]): Promise<any>;
            forwardCall(c: IMsgRpcCall): Promise<any>;
            forwardMessage(msg: IMsgCustom): Promise<any>;
    }
    /**
        * Interfaces may throw errors that include .code field, and it gets propagated to callers (e.g.
        * "NOT_AUTHORIZED"). Its purpose is to be a stable way to distinguish different types of errors.
        * This way the human-friendly error message can be changed without affecting behavior.
        */
    export class ErrorWithCode extends Error {
            code: string | undefined;
            constructor(code: string | undefined, message: string);
    }
    /**
        * Rpc logs everything to the passed-in logger, which is by default the console, but you may
        * provide your own.
        */
    export interface IRpcLogger {
            info?(message: string): void;
            warn?(message: string): void;
    }
}


`;